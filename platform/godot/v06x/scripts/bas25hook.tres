/*
 * Пример использования API отладчика для реализации перехвата
 * загрузки магнитофонного файла BASIC 2.5
 */

global basfile

global signature_2b05 = [0xc5, 0xd5, 0x0e, 0x00, 0x57, 0xdb, 0x01]

global SYNC = 0xe6

class BufferStream {
    var buffer
    var next
    var onfinished
    var index

    def BufferStream(contents) {
        this.buffer = contents
        this.next = 0
        this.index = 0
        this.onfinished = fun() {}

        return this
    }

    // sync & 0x80 -> wait until 0xe6 (and skip it)
    def nextbyte(sync) {
        var b = sync
        while (this.index < this.buffer.size()) {
            b = this.buffer[this.index]
            ++this.index

            if ((sync & 0x80) != 0 && this.index > 1) {
                if (b == SYNC) {
                    // sync found, continue to return following byte
                    sync = 0
                }
                continue
            }
            break
        }

        if (this.index >= this.buffer.size()) {
            this.onfinished(this.next)
        }

        return b
    }

    def size() {
        return this.buffer.size()
    }
}

def BASFile(name)
{
    var mem = read_file(name)

    puts("BASFile: " + name + " size=" + to_string(mem.size()) + "\n")

    var cas = VectorInt()
    for (var i = 0; i < 4; ++i) {
        cas.push_back(0xd3)
    }

    var namestart = name.rfind("/") + 1
    if (name.size() - namestart > 13) {
        namestart = name.size() - 13
    }
    var basname = name.substr(namestart, namestart + 13).toUpperCase()
    for (var i = 0; i < basname.size(); ++i) {
        cas.push_back(int(basname[i]))
    }
    cas.push_back(0)
    cas.push_back(0)
    cas.push_back(0)

    cas.push_back(0xd3)
    cas.push_back(0xd3)
    cas.push_back(0xd3)
    cas.push_back(0)

    var cs = 0
    var zeroseq = 3
    for (var i = 0; i < mem.size(); ++i) {
        cas.push_back(mem[i])
        cs += mem[i]
        if (mem[i] == 0) {
            --zeroseq
            if (zeroseq == 0) {
                break
            }
        }
        else {
            zeroseq = 3
        }
    }
    // pad to 000 if terminal zeroes are missing in .bas file
    for (var i = zeroseq; i > 0; --i) {
        cas.push_back(0)
    }
    cs &= 0xffff

    cas.push_back(cs & 0xff)
    cas.push_back(cs >> 8)

    puts("Loaded, cas.size() = " + to_string(cas.size()) + " checksum=" + to_string(cs) + "\n")

    return BufferStream(cas)
}

def exit_intercept()
{
    // return from the intercepted hook:
    // load return address from stack
    var sp = read_register("sp")
    var ret = read_memory(sp, 1) + read_memory(sp+1, 1) * 256
    // advance SP
    sp += 2
    set_register("sp", sp)
    // set PC to return address
    set_register("pc", ret)
    // continue execution
    script_continue()
}


def check_signature(pc, signature)
{
    for (var i = 0; i < signature.size(); ++i) {
        if (read_memory(pc + i, 0) != signature[i]) {
            return false
        }
    }

    return true
}

def breakfunc(dummy)
{
    if (check_signature(0x2b05, signature_2b05)) {
        var a = read_register("a")

        // return next byte in A
        set_register("a", basfile.nextbyte(a))
        
        // return to the caller
        exit_intercept()
    }
    else {
        script_continue()
    }
}

def attach_bas25_hook() {
    insert_breakpoint(0, 0x2b05, 1) // load byte (see also 0xfb74 for load file)
    add_callback("breakpoint", breakfunc)
    script_attached()
    script_continue()
}

def detach_bas25_hook() {
    remove_breakpoint(0, 0x2b05, 1)
    script_detached()
}

